syntax = "proto3";

package mozaic.protocol;

// ******************************
// *          NETWORK           *
// ******************************

message Frame {
    uint32 channel_num = 1;
    bytes data = 2;
}

message EncryptedPacket {
    bytes nonce = 1;
    bytes data = 2;
}

message Packet {
    uint32 seq_num = 1;
    uint32 ack_num = 2;
    oneof payload {
        Request request = 3;
        Response response = 4;
        CloseRequest close_request = 5;
    }
}

message Request {
    uint32 type_id = 1; 
    bytes data = 2;
}

message Response {
    uint32 request_seq_num = 1;
    uint32 type_id = 2;
    bytes data = 3;
}

message CloseRequest {}


// ******************************
// *         HANDSHAKE          *
// ******************************


// All messages exchanged in the handshake are signed, and put into
// this enveloppe. This way, we can be sure that all handshake messages
// are authentic and trusted.
message SignedMessage {
    bytes data = 1;
    bytes signature = 2;
}

// The client sends a ConnectionRequest to initiate the connection.
// TODO: maybe we want to include some headers here, such as version information
message ConnectionRequest {
    // The client picks a nonce and shares it with the server. The server will
    // then include this nonce in each handshake message it sends, ensuring to
    // the client that the messages are fresh, and we are not being bamboozled
    // with some kind of replay attack.
    bytes client_nonce = 1;

    // A message that allows the server to route this request to a conneciton.
    // (for an example, see the 'routing' section in this file).
    bytes message = 2;
}

message HandshakeServerMessage {
    // The nonce that the client shared with us to protect against replay
    // attacks.
    bytes client_nonce = 1;
    // message contents
    oneof payload {
        ServerChallenge challenge = 2;
        ConnectionAccepted connection_accepted = 3;
        ConnectionRefused connection_refused = 4;
    }
}

// Share a 
message ServerChallenge {
    // The server picks a nonce and shares it with the client, who will
    // have to include it in its challenge response, authenticating the
    // client. 
    bytes server_nonce = 1;
    
    // The public key that the server is offering for key exchange.
    bytes kx_server_pk = 2;
}

message ChallengeResponse {
    // The server nonce, for authentication.
    bytes server_nonce = 1;
    // The public key the client is offering for key exchange.
    bytes kx_client_pk = 2;
}


// The connection was accepted, yay!
message ConnectionAccepted { }

// Something went wrong.
message ConnectionRefused {
    string message = 1;
}


// ******************************
// *          ROUTING           *
// ******************************

// A routing message for a MOZAIC gameserver.
// (this is put in the 'message' field in a ConnectionRequest)
message GameserverConnect {
    oneof connect {
        // connect as a a game client
        ClientConnect client = 1;

        // connect to an existing control channel
        ControlChannelConnect control = 2;
    }
}

message ClientConnect {
    bytes match_uuid = 1;
    uint32 client_id = 2;
}

message ControlChannelConnect {
    bytes uuid = 1;
}